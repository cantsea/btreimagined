@page "/Timetables"
@using MudBlazor
@using System.Net.Http.Json
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Web
@using System.Xml.Linq
@inject HttpClient Http

<PageTitle>Timetables</PageTitle>

<MudContainer MaxWidth="@MaxWidth.Large" Class="mt-6">
    <MudText Typo="@Typo.h4" GutterBottom="true" Align="@Align.Center">
        Bus Timetables
    </MudText>

    <MudPaper Class="p-4 mt-4">
        <MudGrid>
            <MudItem xs="12" md="4">
                <MudSelect T="string" Label="Filter by Route" @bind-Value="_selectedRouteId" Dense="true" Clearable="true">
                    <MudSelectItem T="string" Value='@("ALL")'>All Routes</MudSelectItem>
                    @foreach (var r in _routes)
                    {
                        <MudSelectItem T="string" Value="@r.Id">@r.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>

            <MudItem xs="12" md="4">
                <MudTextField @bind-Value="_timeQuery"
                              Label="Search by Time"
                              Placeholder="1 PM"
                              Dense="true"
                              Adornment="@Adornment.Start"
                              AdornmentIcon="@Icons.Material.Filled.Schedule"
                              Clearable="true"
                              Immediate="true"
                              OnBlurred="@OnTimeBoxBlurred"
                              OnKeyDown="@OnTimeBoxKeyDown">
                </MudTextField>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <MudTable Items="_filteredRows" Hover="true" Dense="true" Class="mt-4">
        <HeaderContent>
            <MudTh>Route</MudTh>
            <MudTh>Starting Point</MudTh>
            <MudTh>Hours of Operation</MudTh>
            <MudTh>First Departure</MudTh>
            <MudTh>Last Departure</MudTh>
            <MudTh>Status</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd>
                <MudStack Row AlignItems="@AlignItems.Center" Spacing="1">
                    <MudAvatar Size="@Size.Medium" Variant="@Variant.Filled" Class="mr-2">
                        @context.Short
                    </MudAvatar>
                    <MudText>@context.RouteName</MudText>
                </MudStack>
            </MudTd>
            <MudTd>@context.StartingPoint</MudTd>
            <MudTd>@($"{ToClock(context.HoursOpen)} - {ToClock(context.HoursClose)}")</MudTd>
            <MudTd>@context.FirstDeparture</MudTd>
            <MudTd>@context.LastDeparture</MudTd>
            <MudTd>
                <MudChip T="string" Color="@StatusColor(context.Status)" Variant="@Variant.Filled" Size="@Size.Small">
                    @context.Status
                </MudChip>
            </MudTd>
        </RowTemplate>
        <NoRecordsContent>
            <MudText Class="p-4" Color="@Color.Secondary">No trips found for the current filters.</MudText>
        </NoRecordsContent>
    </MudTable>
</MudContainer>

@code {
    // ====== CONFIG: your Cloudflare Worker that proxies BT4U ======
    private const string WorkerBase = "https://blue-disk-457f.fionncmurphy.workers.dev/api/bt4u";

    private string _selectedRouteId = "ALL";
    private string? _timeQuery;
    private bool _use24h = false;

    private sealed record RouteDto(string Id, string Name, string Short);
    private sealed record TimetableRow(
        string RouteId, string RouteName, string Short, string StartingPoint,
        string FirstDeparture, string LastDeparture, string Status,
        TimeSpan HoursOpen, TimeSpan HoursClose, bool UsesPM
    );

    private List<RouteDto> _routes = new();
    private List<TimetableRow> _allRows = new();
    private readonly HashSet<string> _activeRoutes = new(StringComparer.OrdinalIgnoreCase);
    private IEnumerable<TimetableRow> _filteredRows => FilterRows();

    // ========= LIFECYCLE =========
    protected override async Task OnInitializedAsync()
    {
        await LoadRoutesAsync();
        await LoadTimetablesAsync();
        await LoadActiveBusesAsync();
        StateHasChanged();
    }

    // ========= UI EVENTS =========
    private Task OnTimeBoxBlurred(FocusEventArgs _) => ApplyTimeFilterAsync();
    private Task OnTimeBoxKeyDown(KeyboardEventArgs e)
        => (e.Key == "Enter") ? ApplyTimeFilterAsync() : Task.CompletedTask;
    private Task ApplyTimeFilterAsync() => InvokeAsync(StateHasChanged);

    // ========= FILTERING =========
    private IEnumerable<TimetableRow> FilterRows()
    {
        IEnumerable<TimetableRow> q = _allRows;

        if (!string.IsNullOrWhiteSpace(_selectedRouteId) && _selectedRouteId != "ALL")
            q = q.Where(r => r.RouteId == _selectedRouteId);

        if (TryParseLooseTime(_timeQuery, out var t))
            q = q.Where(r => TimeFallsInside(r, t));

        return q.ToList();
    }

    private static bool TimeFallsInside(TimetableRow row, TimeSpan t)
    {
        var open = row.HoursOpen;
        var close = row.HoursClose;
        if (close <= open) close += TimeSpan.FromDays(1);
        var tt = t;
        if (tt < open) tt += TimeSpan.FromDays(1);
        return tt >= open && tt <= close;
    }

    private static Color StatusColor(string status) => status switch
    {
        "Active" => Color.Success,
        "On Time" => Color.Success,
        "Early" => Color.Info,
        "Late" => Color.Error,
        "No Active Bus" => Color.Secondary,
        _ => Color.Default
    };

    private static bool TryParseLooseTime(string? input, out TimeSpan time)
    {
        time = default;
        if (string.IsNullOrWhiteSpace(input)) return false;
        if (DateTime.TryParse(input.Trim(), out var dt)) { time = dt.TimeOfDay; return true; }
        if (int.TryParse(input.Trim(), out var hour) && hour is >= 0 and <= 23) { time = new(hour, 0, 0); return true; }
        return false;
    }

    private static string ToClock(TimeSpan t) => DateTime.Today.Add(t).ToString("h:mm tt");

    // ========= API LOADS =========

    private async Task LoadRoutesAsync()
    {
        try
        {
            var url = $"{WorkerBase}?method=GetCurrentRoutes";
            var root = await Http.GetFromJsonAsync<JsonElement>(url);
            _routes = ParseRoutes(root);
        }
        catch { _routes = new(); }
    }

    private async Task LoadTimetablesAsync()
    {
        try
        {
            _allRows = new();
            var serviceDate = DateTime.Today;
            const int NoOfTrips = 999;

            foreach (var r in _routes)
            {
                // Try ISO date, then US date if needed
                var urlIso =
                    $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                    $"&routeShortNames={Uri.EscapeDataString(r.Id)}" +
                    $"&serviceDate={serviceDate:yyyy-MM-dd}" +
                    $"&noOfTrips={NoOfTrips}";

                JsonElement doc;
                try
                {
                    doc = await Http.GetFromJsonAsync<JsonElement>(urlIso);
                }
                catch
                {
                    var urlUs =
                        $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                        $"&routeShortNames={Uri.EscapeDataString(r.Id)}" +
                        $"&serviceDate={serviceDate:MM/dd/yyyy}" +
                        $"&noOfTrips={NoOfTrips}";
                    doc = await Http.GetFromJsonAsync<JsonElement>(urlUs);
                }

                var times = ExtractTimes(doc, out var firstStopName);
                if (times.Count == 0) continue;

                var first = times.Min();
                var last = times.Max();
                var status = _activeRoutes.Contains(r.Id) ? "Active" : "No Active Bus";

                _allRows.Add(new TimetableRow(
                    r.Id, r.Name, r.Short,
                    StartingPoint: string.IsNullOrWhiteSpace(firstStopName) ? "—" : firstStopName,
                    FirstDeparture: first.ToString("h:mm tt"),
                    LastDeparture: last.ToString("h:mm tt"),
                    Status: status,
                    HoursOpen: first.TimeOfDay,
                    HoursClose: last.TimeOfDay,
                    UsesPM: true
                ));
            }
        }
        catch { _allRows = new(); }
    }

    private async Task LoadActiveBusesAsync()
    {
        try
        {
            _activeRoutes.Clear();
            var url = $"{WorkerBase}?method=GetCurrentBusInfo";
            var root = await Http.GetFromJsonAsync<JsonElement>(url);

            if (root.ValueKind == JsonValueKind.Array)
            {
                foreach (var v in root.EnumerateArray())
                {
                    if (v.TryGetProperty("RouteShortName", out var a) && !string.IsNullOrWhiteSpace(a.GetString()))
                        _activeRoutes.Add(a.GetString()!);
                    else if (v.TryGetProperty("routeShortName", out var b) && !string.IsNullOrWhiteSpace(b.GetString()))
                        _activeRoutes.Add(b.GetString()!);
                }
            }
            else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
            {
                var xml = xmlNode.GetString();
                if (!string.IsNullOrWhiteSpace(xml))
                {
                    var x = XDocument.Parse(xml);
                    foreach (var e in x.Descendants().Where(e => string.Equals(e.Name.LocalName, "RouteShortName", StringComparison.OrdinalIgnoreCase)))
                    {
                        var rsn = e.Value?.Trim();
                        if (!string.IsNullOrWhiteSpace(rsn)) _activeRoutes.Add(rsn!);
                    }
                }
            }
        }
        catch { _activeRoutes.Clear(); }
    }

    // ========= PARSERS =========

    private static List<RouteDto> ParseRoutes(JsonElement root)
    {
        var list = new List<RouteDto>();

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var r in root.EnumerateArray())
            {
                var name = TryGet(r, "RouteName") ?? TryGet(r, "routeName") ?? "";
                var shortName = TryGet(r, "RouteShortName") ?? TryGet(r, "routeShortName") ?? "";
                var id = string.IsNullOrWhiteSpace(shortName) ? name : shortName;
                if (!string.IsNullOrWhiteSpace(id))
                    list.Add(new RouteDto(id, string.IsNullOrWhiteSpace(name) ? id : name, string.IsNullOrWhiteSpace(shortName) ? id : shortName));
            }
            return list;
        }

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var routeElems = x.Descendants().Where(d =>
                    d.Elements().Any(c => string.Equals(c.Name.LocalName, "RouteShortName", StringComparison.OrdinalIgnoreCase)) ||
                    d.Elements().Any(c => string.Equals(c.Name.LocalName, "routeShortName", StringComparison.OrdinalIgnoreCase)));

                foreach (var e in routeElems)
                {
                    var shortName = e.Elements().FirstOrDefault(c => string.Equals(c.Name.LocalName, "RouteShortName", StringComparison.OrdinalIgnoreCase) || string.Equals(c.Name.LocalName, "routeShortName", StringComparison.OrdinalIgnoreCase))?.Value?.Trim() ?? "";
                    var name = e.Elements().FirstOrDefault(c => string.Equals(c.Name.LocalName, "RouteName", StringComparison.OrdinalIgnoreCase) || string.Equals(c.Name.LocalName, "routeName", StringComparison.OrdinalIgnoreCase))?.Value?.Trim() ?? "";
                    var id = string.IsNullOrWhiteSpace(shortName) ? name : shortName;
                    if (!string.IsNullOrWhiteSpace(id))
                        list.Add(new RouteDto(id, string.IsNullOrWhiteSpace(name) ? id : name, string.IsNullOrWhiteSpace(shortName) ? id : shortName));
                }
            }
        }
        return list;
    }

    private static List<DateTime> ExtractTimes(JsonElement root, out string firstStopName)
    {
        firstStopName = "";
        var times = new List<DateTime>();

        void Add(string? s)
        {
            if (TryParseBt4uTime(s, out var dt)) times.Add(dt);
        }

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var prop in row.EnumerateObject())
                {
                    var name = prop.Name;
                    var isTimeLike =
                        name.Contains("Depart", StringComparison.OrdinalIgnoreCase) ||
                        name.EndsWith("Time", StringComparison.OrdinalIgnoreCase);

                    if (isTimeLike && prop.Value.ValueKind == JsonValueKind.String)
                        Add(prop.Value.GetString());

                    if (string.IsNullOrWhiteSpace(firstStopName) &&
                        name.Contains("StopName", StringComparison.OrdinalIgnoreCase) &&
                        prop.Value.ValueKind == JsonValueKind.String)
                        firstStopName = prop.Value.GetString() ?? "";
                }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString();
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var e in x.Descendants())
                {
                    var n = e.Name.LocalName;
                    var isTimeLike =
                        n.Contains("Depart", StringComparison.OrdinalIgnoreCase) ||
                        n.EndsWith("Time", StringComparison.OrdinalIgnoreCase);

                    if (isTimeLike) Add(e.Value);

                    if (string.IsNullOrWhiteSpace(firstStopName) &&
                        n.Contains("StopName", StringComparison.OrdinalIgnoreCase))
                        firstStopName = e.Value?.Trim() ?? "";
                }
            }
        }

        // Remove midnight placeholders when other times exist
        if (times.Any(t => t.TimeOfDay != TimeSpan.Zero))
            times = times.Where(t => t.TimeOfDay != TimeSpan.Zero).ToList();

        return times.Distinct().OrderBy(t => t).ToList();
    }

    private static bool TryParseBt4uTime(string? s, out DateTime dt)
    {
        dt = default;
        if (string.IsNullOrWhiteSpace(s)) return false;
        s = s.Trim();

        if (DateTime.TryParse(s, out dt)) return true; // full or time-only in current culture

        if (TimeSpan.TryParse(s, out var ts))
        {
            dt = DateTime.Today.Add(ts);
            return true;
        }

        string[] fmts = {
            "H:mm","HH:mm","h:mm tt","hh:mm tt",
            "M/d/yyyy h:mm tt","M/d/yyyy H:mm","yyyy-MM-dd HH:mm","yyyy-MM-ddTHH:mm:ss"
    };
        return DateTime.TryParseExact(
            s, fmts,
            System.Globalization.CultureInfo.InvariantCulture,
            System.Globalization.DateTimeStyles.None,
            out dt);
    }

    private static string? TryGet(JsonElement obj, string name)
        => obj.ValueKind == JsonValueKind.Object && obj.TryGetProperty(name, out var v) && v.ValueKind == JsonValueKind.String
            ? v.GetString()
            : null;
}
