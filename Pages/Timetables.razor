@page "/"
@using MudBlazor
@using System.Net.Http.Json
@using System.Text.Json
@using System.Xml.Linq
@inject HttpClient Http

<PageTitle>Bus Routes</PageTitle>

@if (_loading)
{
    <MudContainer MaxWidth="MaxWidth.Medium" Class="mt-16 mb-10">
        <MudStack AlignItems="AlignItems.Center" JustifyContent="Justify.Center" Style="min-height:40vh;">
            <MudProgressCircular Size="Size.Large" Indeterminate="true" />
        </MudStack>
    </MudContainer>
}
else
{
    <MudPaper Elevation="5" Outlined="true" Class="pa-3">
        <!-- Fixed logical width so mobile scrolls horizontally instead of squishing -->
        <MudGrid Spacing="2" Class="items-center" Style="min-width: 960px;">
            <!-- Header (Route header contains a dropdown selector) -->
            <MudItem xs="5">
                <MudSelect T="string"
                           Label="Route"
                           Dense="true"
                           Value="@_selectedShort"
                           ValueChanged="@OnRouteChanged"
                           Class="w-full">
                    <MudSelectItem Value="@AllRoutesValue">All Routes</MudSelectItem>
                    @foreach (var r in _rows)
                    {
                        <MudSelectItem Value="@r.Short">@r.Name (@r.Short)</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>

            <MudItem xs="2"><MudText Typo="Typo.subtitle1" Class="fw-bold">Shorthand</MudText></MudItem>
            <MudItem xs="3"><MudText Typo="Typo.subtitle1" Class="fw-bold">Hours of Operation</MudText></MudItem>
            <MudItem xs="2"><MudText Typo="Typo.subtitle1" Class="fw-bold">Status</MudText></MudItem>

            <MudItem xs="12"><MudDivider Class="my-2" /></MudItem>

            <!-- Rows -->
            @for (var i = 0; i < _filtered.Count; i++)
            {
                var r = _filtered[i];
                var bg = i % 2 == 0 ? "#ffffff" : "#f7f7fb";

                <MudItem xs="12" Style="@($"background:{bg};")">
                    <MudGrid Spacing="2" Class="items-center">
                        <MudItem xs="5">
                            <MudText Typo="Typo.body1" Style="@($"color: #{r.RouteColor}; font-weight:600;")">
                                @r.Name
                            </MudText>
                        </MudItem>

                        <MudItem xs="2">
                            <MudChip T="string" Variant="Variant.Outlined"
                                     Style="@($"background-color: #{r.RouteColor}; color: #{r.RouteTextColor}; font-weight:600;")">
                                @r.Short
                            </MudChip>
                        </MudItem>

                        <MudItem xs="3">
                            <MudText Typo="Typo.body1" Color="Color.Secondary">
                                @r.HoursOfOperation
                            </MudText>
                        </MudItem>

                        <MudItem xs="2">
                            <MudChip T="string" Size="Size.Small" Variant="Variant.Filled" Color="@StatusColor(r.Status)">
                                @r.Status
                            </MudChip>
                        </MudItem>
                    </MudGrid>
                </MudItem>
            }
        </MudGrid>
    </MudPaper>
}

@code {
    // ---------- CONFIG ----------
    private const string WorkerBase = "https://blue-disk-457f.fionncmurphy.workers.dev/api/bt4u";
    private const int MaxTrips = 999;
    private const int MaxParallel = 6;
    private static readonly TimeSpan RequestTimeout = TimeSpan.FromSeconds(8);
    private static readonly string ServiceDateIso = DateTime.Today.ToString("yyyy-MM-dd");

    // Sentinel for "All Routes"
    private const string AllRoutesValue = "__ALL__";

    // ---------- MODEL ----------
    private sealed record RouteRow(
        string Short, string Name, string RouteColor, string RouteTextColor,
        string HoursOfOperation, string Status
    );

    // ---------- STATE ----------
    private readonly List<RouteRow> _rows = new();
    private List<RouteRow> _filtered = new();
    private string _selectedShort = AllRoutesValue; // default to All Routes
    private bool _loading = true;

    private readonly Dictionary<string, string> _firstStopCodeCache = new(StringComparer.OrdinalIgnoreCase);

    // ---------- LIFECYCLE ----------
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadRoutesAndStatsAsync();
            _filtered = new(_rows);
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // ---------- DATA LOAD ----------
    private async Task LoadRoutesAndStatsAsync()
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var routesRoot = await Http.GetFromJsonAsync<JsonElement>($"{WorkerBase}?method=GetCurrentRoutes", cts.Token);
            var routes = ParseRoutes(routesRoot);

            _rows.Clear();

            using var sem = new SemaphoreSlim(MaxParallel);
            var tasks = routes.Select(async r =>
            {
                await sem.WaitAsync();
                try
                {
                    var timesTask = GetRouteTimesIsoAsync(r.Short);
                    var statusTask = GetStatusAsync(r.Short);
                    await Task.WhenAll(timesTask, statusTask);

                    var times = timesTask.Result;
                    var hours = times.Count > 0 ? $"{times.Min():h:mm tt} - {times.Max():h:mm tt}" : "—";
                    var status = statusTask.Result;

                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, hours, status));
                }
                catch
                {
                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, "—", "On Time"));
                }
                finally { sem.Release(); }
            }).ToArray();

            await Task.WhenAll(tasks);
            _rows.Sort((a, b) => string.Compare(a.Short, b.Short, StringComparison.OrdinalIgnoreCase));
        }
        catch { _rows.Clear(); }
    }

    // ---------- FILTER ----------
    private async Task OnRouteChanged(string? shortName)
    {
        _selectedShort = string.IsNullOrWhiteSpace(shortName) ? AllRoutesValue : shortName;
        _filtered = _selectedShort == AllRoutesValue
            ? new(_rows)
            : _rows.Where(r => r.Short.Equals(_selectedShort, StringComparison.OrdinalIgnoreCase)).ToList();
        await InvokeAsync(StateHasChanged);
    }

    // ---------- HOURS ----------
    private async Task<List<DateTime>> GetRouteTimesIsoAsync(string routeShortName)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var url = $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                      $"&routeShortNames={Uri.EscapeDataString(routeShortName)}" +
                      $"&serviceDate={ServiceDateIso}&noOfTrips={MaxTrips}";
            var root = await Http.GetFromJsonAsync<JsonElement>(url, cts.Token);
            return ExtractTimes(root);
        }
        catch { return new(); }
    }

    private static List<DateTime> ExtractTimes(JsonElement root)
    {
        var results = new List<DateTime>();

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Value.ValueKind != JsonValueKind.String) continue;
                    var name = p.Name;
                    if (name.Equals("CalculatedDepartureTime", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("CalculatedArrivalTime", StringComparison.OrdinalIgnoreCase))
                    {
                        var s = p.Value.GetString();
                        if (TryParseTime(s, out var dt)) results.Add(dt);
                    }
                }
            }
            return CleanupTimes(results);
        }

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString();
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var times =
                    x.Descendants("DeparturesForRoute")
                     .SelectMany(n => new[]
                     {
                         n.Element("CalculatedDepartureTime")?.Value?.Trim(),
                         n.Element("CalculatedArrivalTime")?.Value?.Trim()
                     })
                     .Where(s => !string.IsNullOrWhiteSpace(s));

                foreach (var s in times!)
                    if (TryParseTime(s, out var dt)) results.Add(dt);
            }
        }

        return CleanupTimes(results);
    }

    // ---------- STATUS ----------
    private async Task<string> GetStatusAsync(string routeShortName)
    {
        try
        {
            var stopCode = await GetFirstStopCodeAsync(routeShortName);
            if (string.IsNullOrWhiteSpace(stopCode)) return "On Time";

            using var cts = new CancellationTokenSource(RequestTimeout);
            var nextRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetNextDepartures&routeShortName={Uri.EscapeDataString(routeShortName)}&stopCode={Uri.EscapeDataString(stopCode)}",
                cts.Token);

            if (TryExtractNextTimes(nextRoot, out var scheduled, out var predicted))
            {
                var minutes = Math.Round((predicted - scheduled).TotalMinutes);
                if (minutes <= -2) return "Running Early";
                if (minutes >= 3) return "Running Late";
                return "On Time";
            }
        }
        catch { }
        return "On Time";
    }

    private async Task<string> GetFirstStopCodeAsync(string routeShortName)
    {
        if (_firstStopCodeCache.TryGetValue(routeShortName, out var cached))
            return cached;

        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var stopsRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetScheduledStopCodes&routeShortName={Uri.EscapeDataString(routeShortName)}",
                cts.Token);

            var code = ParseFirstStopCode(stopsRoot);
            if (!string.IsNullOrWhiteSpace(code))
                _firstStopCodeCache[routeShortName] = code;

            return code;
        }
        catch { return ""; }
    }

    // ---------- PARSERS ----------
    private static Color StatusColor(string s) => s switch
    {
        "Running Early" => Color.Info,
        "Running Late" => Color.Error,
        "On Time" => Color.Success,
        _ => Color.Default
    };

    private static List<(string Short, string Name, string RouteColor, string RouteTextColor)> ParseRoutes(JsonElement root)
    {
        var list = new List<(string, string, string, string)>();

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var doc = XDocument.Parse(xml);
                foreach (var e in doc.Descendants("CurrentRoutes"))
                {
                    var name = e.Element("RouteName")?.Value?.Trim() ?? "";
                    var shortName = e.Element("RouteShortName")?.Value?.Trim() ?? "";
                    var color = e.Element("RouteColor")?.Value?.Trim() ?? "888888";
                    var text = e.Element("RouteTextColor")?.Value?.Trim() ?? "FFFFFF";

                    if (!string.IsNullOrWhiteSpace(shortName) && !string.IsNullOrWhiteSpace(name))
                        list.Add((shortName, name, color, text));
                }
            }
        }
        return list;
    }

    private static string ParseFirstStopCode(JsonElement root)
    {
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Name.Contains("StopCode", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                    if (p.Name.Equals("Code", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var code = x.Descendants().FirstOrDefault(e =>
                    e.Name.LocalName.Equals("StopCode", StringComparison.OrdinalIgnoreCase) ||
                    e.Name.LocalName.Equals("Code", StringComparison.OrdinalIgnoreCase));
                if (code is not null) return code.Value?.Trim() ?? "";
            }
        }
        return "";
    }

    private static bool TryExtractNextTimes(JsonElement root, out DateTime scheduled, out DateTime predicted)
    {
        scheduled = default;
        predicted = default;

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                var (sch, est) = ExtractTimesFromObj(row);
                if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants("DeparturesForRoute"))
                {
                    DateTime sch = default, est = default;

                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                   ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var predStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                   ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && TryParseTime(schedStr, out var a)) sch = a;
                    if (!string.IsNullOrWhiteSpace(predStr) && TryParseTime(predStr, out var b)) est = b;

                    if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
                }
            }
        }
        return false;

        static (DateTime sch, DateTime est) ExtractTimesFromObj(JsonElement obj)
        {
            DateTime sch = default, est = default;
            foreach (var p in obj.EnumerateObject())
            {
                if (p.Value.ValueKind != JsonValueKind.String) continue;
                var name = p.Name;
                var s = p.Value.GetString();

                if ((name.Contains("Scheduled", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Schedule", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var a)) sch = a;

                if ((name.Contains("Calculated", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Pred", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Est", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var b)) est = b;
            }
            return (sch, est);
        }
    }

    private static bool TryParseTime(string? s, out DateTime dt) => TryParseDate(s, out dt);

    // STRICT ISO 8601 with offset (e.g., 2025-10-20T21:47:02-04:00)
    private static bool TryParseDate(string? s, out DateTime dt)
    {
        dt = default;
        if (string.IsNullOrWhiteSpace(s)) return false;

        if (DateTimeOffset.TryParseExact(
                s.Trim(),
                "yyyy-MM-dd'T'HH:mm:sszzz",
                System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None,
                out var dto))
        {
            dt = dto.LocalDateTime;
            return true;
        }
        return false;
    }

    private static List<DateTime> CleanupTimes(List<DateTime> times)
    {
        if (times.Any(t => t.TimeOfDay != TimeSpan.Zero))
            times = times.Where(t => t.TimeOfDay != TimeSpan.Zero).ToList();

        times = times.Where(t => t.Year >= 2000).ToList();

        return times.Distinct().OrderBy(t => t).ToList();
    }
}
