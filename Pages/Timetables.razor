@page "/"
@using MudBlazor
@using System.Net.Http.Json
@using System.Text.Json
@using System.Xml.Linq
@inject HttpClient Http

<PageTitle>Bus Routes</PageTitle>

@if (_loading)
{
    <MudContainer>
        <MudStack AlignItems="AlignItems.Center" JustifyContent="Justify.Center">
            <MudProgressCircular Size="Size.Medium" Indeterminate="true" />
        </MudStack>
    </MudContainer>
}
else
{
    <MudCard Outlined="true">
        <MudDataGrid Elevation="10" T="RouteRow"
                     Items="_rows"
                     Dense="true"
                     Bordered="true"
                     Striped="true"
                     Hover="true"
                     ReadOnly="true">

            <Columns>
                <!-- Route (colored text) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Route"
                                Property="@(r => r.Name)"
                                SortBy="@(r => r.Name)" Filterable="true">
                    <CellTemplate>
                        <MudText Typo="Typo.body1"
                                 Style="@($"color: #{context.Item.RouteColor}; font-weight:600;")">
                            @context.Item.Name
                        </MudText>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Shorthand (chip) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Shorthand"
                                Property="@(r => r.Short)"
                                SortBy="@(r => r.Short)">
                    <CellTemplate>
                        <MudChip Variant="Variant.Outlined"
                                 Style="@($"background-color: #{context.Item.RouteColor}; color: #{context.Item.RouteTextColor}; font-weight:600;")">
                            @context.Item.Short
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Hours of Operation -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Hours of Operation"
                                Property="@(r => r.HoursOfOperation)"
                                SortBy="@(r => r.HoursOfOperation)" Filterable="true">
                    <CellTemplate>
                        <MudText Typo="Typo.body1" Color="Color.Secondary">
                            @context.Item.HoursOfOperation
                        </MudText>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Status (colored chip) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Status"
                                Property="@(r => r.Status)"
                                SortBy="@(r => r.Status)">
                    <CellTemplate>
                        <MudChip Size="Size.Small"
                                 Variant="Variant.Filled"
                                 Color="@StatusColor(context.Item.Status)">
                            @context.Item.Status
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>
            </Columns>

            <PagerContent>
                <MudDataGridPager PageSizeOptions="new int[] { 25, 50, 100 }" />
            </PagerContent>
        </MudDataGrid>
    </MudCard>

}

@code {
    // ---------- CONFIG ----------
    private const string WorkerBase = "https://blue-disk-457f.fionncmurphy.workers.dev/api/bt4u";
    private const int MaxTrips = 999;
    private const int MaxParallel = 6;
    private static readonly TimeSpan RequestTimeout = TimeSpan.FromSeconds(8);
    private static readonly string ServiceDateIso = DateTime.Today.ToString("yyyy-MM-dd");

    // ---------- MODEL ----------
    private sealed record RouteRow(
        string Short, string Name, string RouteColor, string RouteTextColor,
        string HoursOfOperation, string Status
    );

    // ---------- STATE ----------
    private readonly List<RouteRow> _rows = new();
    private bool _loading = true;
    private readonly Dictionary<string, string> _firstStopCodeCache = new(StringComparer.OrdinalIgnoreCase);

    // ---------- LIFECYCLE ----------
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadRoutesAndStatsAsync();
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // ---------- DATA LOAD ----------
    private async Task LoadRoutesAndStatsAsync()
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var routesRoot = await Http.GetFromJsonAsync<JsonElement>($"{WorkerBase}?method=GetCurrentRoutes", cts.Token);
            var routes = ParseRoutes(routesRoot);

            _rows.Clear();

            using var sem = new SemaphoreSlim(MaxParallel);
            var tasks = routes.Select(async r =>
            {
                await sem.WaitAsync();
                try
                {
                    var timesTask = GetRouteTimesIsoAsync(r.Short);
                    var statusTask = GetStatusAsync(r.Short);
                    await Task.WhenAll(timesTask, statusTask);

                    var times = timesTask.Result;
                    var hours = times.Count > 0 ? $"{times.Min():h:mm tt} - {times.Max():h:mm tt}" : "—";
                    var status = statusTask.Result;

                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, hours, status));
                }
                catch
                {
                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, "—", "On Time"));
                }
                finally { sem.Release(); }
            }).ToArray();

            await Task.WhenAll(tasks);
            _rows.Sort((a, b) => string.Compare(a.Short, b.Short, StringComparison.OrdinalIgnoreCase));
        }
        catch { _rows.Clear(); }
    }

    // ---------- HOURS ----------
    private async Task<List<DateTime>> GetRouteTimesIsoAsync(string routeShortName)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var url = $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                      $"&routeShortNames={Uri.EscapeDataString(routeShortName)}" +
                      $"&serviceDate={ServiceDateIso}&noOfTrips={MaxTrips}";
            var root = await Http.GetFromJsonAsync<JsonElement>(url, cts.Token);
            return ExtractTimes(root);
        }
        catch { return new(); }
    }

    private static List<DateTime> ExtractTimes(JsonElement root)
    {
        var results = new List<DateTime>();

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Value.ValueKind != JsonValueKind.String) continue;
                    var name = p.Name;
                    if (name.Equals("CalculatedDepartureTime", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("CalculatedArrivalTime", StringComparison.OrdinalIgnoreCase))
                    {
                        var s = p.Value.GetString();
                        if (TryParseTime(s, out var dt)) results.Add(dt);
                    }
                }
            }
            return CleanupTimes(results);
        }

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString();
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var times =
                    x.Descendants("DeparturesForRoute")
                     .SelectMany(n => new[]
                     {
                         n.Element("CalculatedDepartureTime")?.Value?.Trim(),
                         n.Element("CalculatedArrivalTime")?.Value?.Trim()
                     })
                     .Where(s => !string.IsNullOrWhiteSpace(s));

                foreach (var s in times!)
                    if (TryParseTime(s, out var dt)) results.Add(dt);
            }
        }

        return CleanupTimes(results);
    }

    // ---------- STATUS ----------
    private async Task<string> GetStatusAsync(string routeShortName)
    {
        try
        {
            var stopCode = await GetFirstStopCodeAsync(routeShortName);
            if (string.IsNullOrWhiteSpace(stopCode)) return "On Time";

            using var cts = new CancellationTokenSource(RequestTimeout);
            var nextRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetNextDepartures&routeShortName={Uri.EscapeDataString(routeShortName)}&stopCode={Uri.EscapeDataString(stopCode)}",
                cts.Token);

            if (TryExtractNextTimes(nextRoot, out var scheduled, out var predicted))
            {
                var minutes = Math.Round((predicted - scheduled).TotalMinutes);
                if (minutes <= -2) return "Running Early";
                if (minutes >= 3) return "Running Late";
                return "On Time";
            }
        }
        catch { }
        return "On Time";
    }

    private async Task<string> GetFirstStopCodeAsync(string routeShortName)
    {
        if (_firstStopCodeCache.TryGetValue(routeShortName, out var cached))
            return cached;

        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var stopsRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetScheduledStopCodes&routeShortName={Uri.EscapeDataString(routeShortName)}",
                cts.Token);

            var code = ParseFirstStopCode(stopsRoot);
            if (!string.IsNullOrWhiteSpace(code))
                _firstStopCodeCache[routeShortName] = code;

            return code;
        }
        catch { return ""; }
    }

    // ---------- PARSERS ----------
    private static Color StatusColor(string s) => s switch
    {
        "Running Early" => Color.Info,
        "Running Late" => Color.Error,
        "On Time" => Color.Success,
        _ => Color.Default
    };

    private static List<(string Short, string Name, string RouteColor, string RouteTextColor)> ParseRoutes(JsonElement root)
    {
        var list = new List<(string, string, string, string)>();

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var doc = XDocument.Parse(xml);
                foreach (var e in doc.Descendants("CurrentRoutes"))
                {
                    var name = e.Element("RouteName")?.Value?.Trim() ?? "";
                    var shortName = e.Element("RouteShortName")?.Value?.Trim() ?? "";
                    var color = e.Element("RouteColor")?.Value?.Trim() ?? "888888";
                    var text = e.Element("RouteTextColor")?.Value?.Trim() ?? "FFFFFF";

                    if (!string.IsNullOrWhiteSpace(shortName) && !string.IsNullOrWhiteSpace(name))
                        list.Add((shortName, name, color, text));
                }
            }
        }
        return list;
    }

    private static string ParseFirstStopCode(JsonElement root)
    {
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Name.Contains("StopCode", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                    if (p.Name.Equals("Code", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var code = x.Descendants().FirstOrDefault(e =>
                    e.Name.LocalName.Equals("StopCode", StringComparison.OrdinalIgnoreCase) ||
                    e.Name.LocalName.Equals("Code", StringComparison.OrdinalIgnoreCase));
                if (code is not null) return code.Value?.Trim() ?? "";
            }
        }
        return "";
    }

    private static bool TryExtractNextTimes(JsonElement root, out DateTime scheduled, out DateTime predicted)
    {
        scheduled = default;
        predicted = default;

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                var (sch, est) = ExtractTimesFromObj(row);
                if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants("DeparturesForRoute"))
                {
                    DateTime sch = default, est = default;

                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                   ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var predStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                   ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && TryParseTime(schedStr, out var a)) sch = a;
                    if (!string.IsNullOrWhiteSpace(predStr) && TryParseTime(predStr, out var b)) est = b;

                    if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
                }
            }
        }
        return false;

        static (DateTime sch, DateTime est) ExtractTimesFromObj(JsonElement obj)
        {
            DateTime sch = default, est = default;
            foreach (var p in obj.EnumerateObject())
            {
                if (p.Value.ValueKind != JsonValueKind.String) continue;
                var name = p.Name;
                var s = p.Value.GetString();

                if ((name.Contains("Scheduled", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Schedule", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var a)) sch = a;

                if ((name.Contains("Calculated", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Pred", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Est", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var b)) est = b;
            }
            return (sch, est);
        }
    }

    private static bool TryParseTime(string? s, out DateTime dt) => TryParseDate(s, out dt);

    private static bool TryParseDate(string? s, out DateTime dt)
    {
        dt = default;
        if (string.IsNullOrWhiteSpace(s)) return false;

        if (DateTimeOffset.TryParseExact(
                s.Trim(),
                "yyyy-MM-dd'T'HH:mm:sszzz",
                System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None,
                out var dto))
        {
            dt = dto.LocalDateTime;
            return true;
        }
        return false;
    }

    private static List<DateTime> CleanupTimes(List<DateTime> times)
    {
        if (times.Any(t => t.TimeOfDay != TimeSpan.Zero))
            times = times.Where(t => t.TimeOfDay != TimeSpan.Zero).ToList();

        times = times.Where(t => t.Year >= 2000).ToList();

        return times.Distinct().OrderBy(t => t).ToList();
    }
}
