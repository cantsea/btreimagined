@page "/"
@using MudBlazor
@using System.Net.Http.Json
@using System.Text.Json
@using System.Xml.Linq
@inject HttpClient Http

<PageTitle>Bus Routes</PageTitle>

@if (_loading)
{
    <MudContainer>
        <MudStack AlignItems="AlignItems.Center" JustifyContent="Justify.Center">
            <MudProgressCircular Size="Size.Medium" Indeterminate="true" />
        </MudStack>
    </MudContainer>
}
else
{
    <MudCard Outlined="true">
        <MudDataGrid Elevation="10" T="RouteRow"
                     Items="_rows"
                     Dense="true"
                     Bordered="true"
                     Striped="true"
                     Hover="true"
                     ReadOnly="true">

            <Columns>
                <!-- Route (colored text) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Route"
                                Property="@(r => r.Name)"
                                SortBy="@(r => r.Name)" Filterable="true">
                    <CellTemplate>
                        <MudText Typo="Typo.body1"
                                 Style="@($"color: #{context.Item.RouteColor}; font-weight:600;")">
                            @context.Item.Name
                        </MudText>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Shorthand (chip) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Shorthand"
                                Property="@(r => r.Short)"
                                SortBy="@(r => r.Short)">
                    <CellTemplate>
                        <MudChip Variant="Variant.Outlined"
                                 Style="@($"background-color: #{context.Item.RouteColor}; color: #{context.Item.RouteTextColor}; font-weight:600;")">
                            @context.Item.Short
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Hours of Operation -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Hours of Operation"
                                Property="@(r => r.HoursOfOperation)"
                                SortBy="@(r => r.HoursOfOperation)" Filterable="true">
                    <CellTemplate>
                        <MudText Typo="Typo.body1" Color="Color.Secondary">
                            @context.Item.HoursOfOperation
                        </MudText>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Status (colored chip with minutes when Early/Late) -->
                <PropertyColumn T="RouteRow" TProperty="string"
                                Title="Status"
                                Property="@(r => r.Status)"
                                SortBy="@(r => r.Status)">
                    <CellTemplate>
                        <MudChip Size="Size.Small"
                                 Variant="Variant.Filled"
                                 Color="@StatusColor(context.Item.Status)">
                            @context.Item.Status
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>
            </Columns>

            <PagerContent>
                <MudDataGridPager PageSizeOptions="new int[] { 25, 50, 100 }" />
            </PagerContent>
        </MudDataGrid>
    </MudCard>

}

@code {
    // ---------- CONFIG ----------
    private const string WorkerBase = "https://blue-disk-457f.fionncmurphy.workers.dev/api/bt4u";
    private const int MaxTrips = 999;
    private const int MaxParallel = 6;
    private static readonly TimeSpan RequestTimeout = TimeSpan.FromSeconds(8);
    private static readonly string ServiceDateIso = DateTime.Today.ToString("yyyy-MM-dd");

    // ---------- MODEL ----------
    private sealed record RouteRow(
        string Short, string Name, string RouteColor, string RouteTextColor,
        string HoursOfOperation, string Status
    );

    // ---------- STATE ----------
    private readonly List<RouteRow> _rows = new();
    private bool _loading = true;
    private readonly Dictionary<string, string> _firstStopCodeCache = new(StringComparer.OrdinalIgnoreCase);

    // ---------- LIFECYCLE ----------
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadRoutesAndStatsAsync();
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // ---------- DATA LOAD ----------
    private async Task LoadRoutesAndStatsAsync()
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var routesRoot = await Http.GetFromJsonAsync<JsonElement>($"{WorkerBase}?method=GetCurrentRoutes", cts.Token);
            var routes = ParseRoutes(routesRoot);

            _rows.Clear();

            using var sem = new SemaphoreSlim(MaxParallel);
            var tasks = routes.Select(async r =>
            {
                await sem.WaitAsync();
                try
                {
                    var timesTask = GetRouteTimesIsoAsync(r.Short);
                    var statusTask = GetStatusAsync(r.Short);
                    await Task.WhenAll(timesTask, statusTask);

                    var times = timesTask.Result;
                    var hours = times.Count > 0 ? $"{times.Min():h:mm tt} - {times.Max():h:mm tt}" : "—";
                    var status = statusTask.Result;

                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, hours, status));
                }
                catch
                {
                    lock (_rows)
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, "—", "On Time"));
                }
                finally { sem.Release(); }
            }).ToArray();

            await Task.WhenAll(tasks);
            _rows.Sort((a, b) => string.Compare(a.Short, b.Short, StringComparison.OrdinalIgnoreCase));
        }
        catch { _rows.Clear(); }
    }

    // ---------- HOURS ----------
    private async Task<List<DateTime>> GetRouteTimesIsoAsync(string routeShortName)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var url = $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                      $"&routeShortNames={Uri.EscapeDataString(routeShortName)}" +
                      $"&serviceDate={ServiceDateIso}&noOfTrips={MaxTrips}";
            var root = await Http.GetFromJsonAsync<JsonElement>(url, cts.Token);
            return ExtractTimes(root);
        }
        catch { return new(); }
    }

    private static List<DateTime> ExtractTimes(JsonElement root)
    {
        var results = new List<DateTime>();

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Value.ValueKind != JsonValueKind.String) continue;
                    var name = p.Name;
                    if (name.Equals("CalculatedDepartureTime", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("CalculatedArrivalTime", StringComparison.OrdinalIgnoreCase))
                    {
                        var s = p.Value.GetString();
                        if (TryParseTime(s, out var dt)) results.Add(dt);
                    }
                }
            }
            return CleanupTimes(results);
        }

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString();
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var times =
                    x.Descendants("DeparturesForRoute")
                     .SelectMany(n => new[]
                     {
                         n.Element("CalculatedDepartureTime")?.Value?.Trim(),
                         n.Element("CalculatedArrivalTime")?.Value?.Trim()
                     })
                     .Where(s => !string.IsNullOrWhiteSpace(s));

                foreach (var s in times!)
                    if (TryParseTime(s, out var dt)) results.Add(dt);
            }
        }

        return CleanupTimes(results);
    }

    // ---------- STATUS (Vehicle-first median delay, then fallback) ----------
    private async Task<string> GetStatusAsync(string routeShortName)
    {
        // 1) Best: vehicle-level adherence based on TripID+StopCode (from GetCurrentBusInfo)
        var fromVehicles = await TryGetStatusFromVehiclesAsync(routeShortName);
        if (!string.IsNullOrWhiteSpace(fromVehicles))
            return fromVehicles!;

        // 2) Fallback: anchor stop via GetNextDepartures (median over next few)
        try
        {
            var stopCode = await GetFirstStopCodeAsync(routeShortName);
            if (string.IsNullOrWhiteSpace(stopCode)) return "On Time";

            using var cts = new CancellationTokenSource(RequestTimeout);
            var nextRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetNextDepartures&routeShortName={Uri.EscapeDataString(routeShortName)}&stopCode={Uri.EscapeDataString(stopCode)}",
                cts.Token);

            var pairs = ExtractNextPairs(nextRoot);
            var delays = pairs.OrderBy(p => p.predicted).Take(3)
                              .Select(p => Math.Round((p.predicted - p.scheduled).TotalMinutes))
                              .ToList();

            if (delays.Count > 0)
            {
                var med = Median(delays);
                return StatusLabelFromDelay(med);
            }
        }
        catch { /* ignore */ }

        return "On Time";
    }
    private async Task<string> GetFirstStopCodeAsync(string routeShortName)
    {
        if (_firstStopCodeCache.TryGetValue(routeShortName, out var cached))
            return cached;

        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var stopsRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetScheduledStopCodes&routeShortName={Uri.EscapeDataString(routeShortName)}",
                cts.Token);

            var code = ParseFirstStopCode(stopsRoot);
            if (!string.IsNullOrWhiteSpace(code))
                _firstStopCodeCache[routeShortName] = code;

            return code;
        }
        catch
        {
            return "";
        }
    }

    // Vehicle-first: compute median delay across active vehicles on this route
    private async Task<string?> TryGetStatusFromVehiclesAsync(string routeShortName)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var root = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetCurrentBusInfo", cts.Token);

            if (root.ValueKind != JsonValueKind.Object || !root.TryGetProperty("xml", out var xmlNode))
                return null;

            var xml = xmlNode.GetString() ?? "";
            if (string.IsNullOrWhiteSpace(xml)) return null;

            var x = XDocument.Parse(xml);

            var vehicles = x.Descendants("LatestInfoTable")
                            .Where(n => string.Equals(n.Element("RouteShortName")?.Value?.Trim(), routeShortName, StringComparison.OrdinalIgnoreCase))
                            .Select(n => new
                            {
                                TripID = n.Element("TripID")?.Value?.Trim(),
                                StopCode = n.Element("StopCode")?.Value?.Trim()
                            })
                            .Where(v => !string.IsNullOrWhiteSpace(v.TripID) && !string.IsNullOrWhiteSpace(v.StopCode))
                            .ToList();

            if (vehicles.Count == 0) return null;

            var delays = new List<double>();
            using var sem = new SemaphoreSlim(MaxParallel);
            var tasks = vehicles.Select(async v =>
            {
                await sem.WaitAsync();
                try
                {
                    var d = await GetVehicleDelayMinutesAsync(v.TripID!, v.StopCode!);
                    if (d is double m) lock (delays) delays.Add(m);
                }
                finally { sem.Release(); }
            }).ToArray();

            await Task.WhenAll(tasks);
            if (delays.Count == 0) return null;

            var med = Median(delays);
            return StatusLabelFromDelay(med);
        }
        catch
        {
            return null;
        }
    }

    // For a specific vehicle, compare Calculated vs Scheduled at its current (or next) stop
    private async Task<double?> GetVehicleDelayMinutesAsync(string tripId, string stopCode)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var tripRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetArrivalAndDepartureTimesForTrip&tripID={Uri.EscapeDataString(tripId)}",
                cts.Token);

            var rows = ExtractTripStopTimes(tripRoot);
            if (rows.Count == 0) return null;

            (string stop, DateTime sch, DateTime calc)? best =
                rows.FirstOrDefault(r => string.Equals(r.stopCode, stopCode, StringComparison.OrdinalIgnoreCase));

            if (best is null)
            {
                var now = DateTime.Now;
                best = rows.Where(r => r.calc > now.AddSeconds(-90))
                           .OrderBy(r => r.calc)
                           .Cast<(string stop, DateTime sch, DateTime calc)?>()
                           .FirstOrDefault();
            }

            if (best is null) return null;
            var b = best.Value;
            return Math.Round((b.calc - b.sch).TotalMinutes);
        }
        catch { return null; }
    }

    // ---------- PARSERS ----------
    // Color now keys off the prefix, since we include (+Xm) in the label
    private static Color StatusColor(string s) => s switch
    {
        _ when s.StartsWith("Running Early", StringComparison.OrdinalIgnoreCase) => Color.Info,
        _ when s.StartsWith("Running Late", StringComparison.OrdinalIgnoreCase) => Color.Error,
        _ when s.StartsWith("On Time", StringComparison.OrdinalIgnoreCase) => Color.Success,
        _ => Color.Default
    };

    private static List<(string Short, string Name, string RouteColor, string RouteTextColor)> ParseRoutes(JsonElement root)
    {
        var list = new List<(string, string, string, string)>();

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var doc = XDocument.Parse(xml);
                foreach (var e in doc.Descendants("CurrentRoutes"))
                {
                    var name = e.Element("RouteName")?.Value?.Trim() ?? "";
                    var shortName = e.Element("RouteShortName")?.Value?.Trim() ?? "";
                    var color = e.Element("RouteColor")?.Value?.Trim() ?? "888888";
                    var text = e.Element("RouteTextColor")?.Value?.Trim() ?? "FFFFFF";

                    if (!string.IsNullOrWhiteSpace(shortName) && !string.IsNullOrWhiteSpace(name))
                        list.Add((shortName, name, color, text));
                }
            }
        }
        return list;
    }

    private static string ParseFirstStopCode(JsonElement root)
    {
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Name.Contains("StopCode", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                    if (p.Name.Equals("Code", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var code = x.Descendants().FirstOrDefault(e =>
                    e.Name.LocalName.Equals("StopCode", StringComparison.OrdinalIgnoreCase) ||
                    e.Name.LocalName.Equals("Code", StringComparison.OrdinalIgnoreCase));
                if (code is not null) return code.Value?.Trim() ?? "";
            }
        }
        return "";
    }

    // Extract multiple (scheduled, predicted) pairs from NextDepartures to compute median
    private static List<(DateTime scheduled, DateTime predicted)> ExtractNextPairs(JsonElement root)
    {
        var pairs = new List<(DateTime, DateTime)>();

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                DateTime sch = default, est = default;
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Value.ValueKind != JsonValueKind.String) continue;
                    var name = p.Name;
                    var s = p.Value.GetString();

                    if ((name.Contains("Scheduled", StringComparison.OrdinalIgnoreCase) ||
                         name.Contains("Schedule", StringComparison.OrdinalIgnoreCase)) &&
                        TryParseTime(s, out var a)) sch = a;

                    if ((name.Contains("Calculated", StringComparison.OrdinalIgnoreCase) ||
                         name.Contains("Pred", StringComparison.OrdinalIgnoreCase) ||
                         name.Contains("Est", StringComparison.OrdinalIgnoreCase)) &&
                        TryParseTime(s, out var b)) est = b;
                }
                if (sch != default && est != default) pairs.Add((sch, est));
            }
            return pairs;
        }

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants("DeparturesForRoute"))
                {
                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                   ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var predStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                   ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && !string.IsNullOrWhiteSpace(predStr) &&
                        TryParseTime(schedStr, out var sch) && TryParseTime(predStr, out var est))
                    {
                        pairs.Add((sch, est));
                    }
                }
            }
        }
        return pairs;
    }

    // Parse (stopCode, scheduled, calculated) rows from a Trip response
    private static List<(string stopCode, DateTime sch, DateTime calc)> ExtractTripStopTimes(JsonElement root)
    {
        var list = new List<(string, DateTime, DateTime)>();

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants())
                {
                    var stop = n.Element("StopCode")?.Value?.Trim()
                             ?? n.Element("Code")?.Value?.Trim();
                    if (string.IsNullOrWhiteSpace(stop)) continue;

                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var calcStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && !string.IsNullOrWhiteSpace(calcStr) &&
                        TryParseTime(schedStr, out var sch) && TryParseTime(calcStr, out var calc))
                    {
                        list.Add((stop, sch, calc));
                    }
                }
            }
        }
        return list;
    }

    // ---------- SMALL UTILS ----------
    private static string StatusLabelFromDelay(double minutes)
    {
        // minutes is already rounded
        if (minutes <= -2) return $"Running Early ({minutes:+#;-#;0}m)";
        if (minutes >= 3) return $"Running Late ({minutes:+#;-#;0}m)";
        return "On Time";
    }

    private static double Median(IReadOnlyList<double> xs)
    {
        if (xs is null || xs.Count == 0) return 0;
        var a = xs.OrderBy(v => v).ToArray();
        int n = a.Length;
        return (n % 2 == 1) ? a[n / 2] : 0.5 * (a[n / 2 - 1] + a[n / 2]);
    }

    private static bool TryExtractNextTimes(JsonElement root, out DateTime scheduled, out DateTime predicted)
    {
        // (kept for compatibility; used nowhere now, but safe to leave)
        scheduled = default;
        predicted = default;

        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                var (sch, est) = ExtractTimesFromObj(row);
                if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants("DeparturesForRoute"))
                {
                    DateTime sch = default, est = default;

                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                   ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var predStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                   ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && TryParseTime(schedStr, out var a)) sch = a;
                    if (!string.IsNullOrWhiteSpace(predStr) && TryParseTime(predStr, out var b)) est = b;

                    if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
                }
            }
        }
        return false;

        static (DateTime sch, DateTime est) ExtractTimesFromObj(JsonElement obj)
        {
            DateTime sch = default, est = default;
            foreach (var p in obj.EnumerateObject())
            {
                if (p.Value.ValueKind != JsonValueKind.String) continue;
                var name = p.Name;
                var s = p.Value.GetString();

                if ((name.Contains("Scheduled", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Schedule", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var a)) sch = a;

                if ((name.Contains("Calculated", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Pred", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Est", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var b)) est = b;
            }
            return (sch, est);
        }
    }

    private static bool TryParseTime(string? s, out DateTime dt) => TryParseDate(s, out dt);

    private static bool TryParseDate(string? s, out DateTime dt)
    {
        dt = default;
        if (string.IsNullOrWhiteSpace(s)) return false;

        if (DateTimeOffset.TryParseExact(
                s.Trim(),
                "yyyy-MM-dd'T'HH:mm:sszzz",
                System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None,
                out var dto))
        {
            dt = dto.LocalDateTime;
            return true;
        }
        return false;
    }

    private static List<DateTime> CleanupTimes(List<DateTime> times)
    {
        if (times.Any(t => t.TimeOfDay != TimeSpan.Zero))
            times = times.Where(t => t.TimeOfDay != TimeSpan.Zero).ToList();

        times = times.Where(t => t.Year >= 2000).ToList();

        return times.Distinct().OrderBy(t => t).ToList();
    }
}
