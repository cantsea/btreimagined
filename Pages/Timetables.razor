@page "/"
@using MudBlazor
@using System.Net.Http.Json
@using System.Text.Json
@using System.Xml.Linq
@inject HttpClient Http

<PageTitle>Bus Routes</PageTitle>

@if (_loading)
{
    <MudContainer MaxWidth="MaxWidth.Medium" Class="mt-16 mb-10">
        <MudStack AlignItems="AlignItems.Center" JustifyContent="Justify.Center" Style="min-height:40vh;">
            <MudProgressCircular Size="Size.Large" Indeterminate="true" />
            <MudText Typo="Typo.subtitle1" Class="mt-2" Color="Color.Secondary">Loading timetable…</MudText>
        </MudStack>
    </MudContainer>
}
else
{
    <MudContainer MaxWidth="MaxWidth.Medium" Class="mt-6 mb-10">
        <MudText Typo="Typo.h4" Align="Align.Center" GutterBottom="true">
            Blacksburg Transit Routes
        </MudText>

        <!-- Filter -->
        <MudPaper Class="p-4 mb-3" Elevation="2">
            <MudSelect T="RouteRow"
                       Label="Filter by Route"
                       Value="@_selected"
                       ValueChanged="@OnRouteChanged"
                       Dense="true"
                       Clearable="true"
                       Class="w-full">
                @foreach (var r in _rows)
                {
                    <MudSelectItem Value="@r">
                        <div style="@($"display:flex;align-items:center;gap:8px;color:#{r.RouteTextColor};background-color:#{r.RouteColor};padding:4px 8px;border-radius:6px;")">
                            <span>@r.Name</span>
                            <span style="opacity:.8;">(@r.Short)</span>
                        </div>
                    </MudSelectItem>
                }
            </MudSelect>
        </MudPaper>

        <!-- Header -->
        <MudCard Outlined="true" Class="mb-0" Style="border-bottom-left-radius:0;border-bottom-right-radius:0;">
            <MudCardContent Class="py-2">
                <MudGrid Class="items-center">
                    <MudItem xs="5"><MudText Typo="Typo.subtitle1" Style="font-weight:700;">Route</MudText></MudItem>
                    <MudItem xs="2"><MudText Typo="Typo.subtitle1" Style="font-weight:700;">Shorthand</MudText></MudItem>
                    <MudItem xs="3"><MudText Typo="Typo.subtitle1" Style="font-weight:700;">Hours of Operation</MudText></MudItem>
                    <MudItem xs="2"><MudText Typo="Typo.subtitle1" Style="font-weight:700;">Status</MudText></MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>

        <!-- Rows -->
        @for (var i = 0; i < _filtered.Count; i++)
        {
            var r = _filtered[i];
            var bg = i % 2 == 0 ? "#ffffff" : "#f7f7fb";

            <MudCard Outlined="true" Style="@($"background:{bg};border-radius:0;box-shadow:none;border-top:0;")">
                <MudCardContent Class="py-2 px-3">
                    <MudGrid Class="items-center">
                        <MudItem xs="5">
                            <MudText Typo="Typo.body1" Style="@($"color: #{r.RouteColor}; font-weight:600;")">
                                @r.Name
                            </MudText>
                        </MudItem>

                        <MudItem xs="2">
                            <MudChip T="string"
                                     Variant="Variant.Outlined"
                                     Style="@($"background-color: #{r.RouteColor}; color: #{r.RouteTextColor}; font-weight:600;")">
                                @r.Short
                            </MudChip>
                        </MudItem>

                        <MudItem xs="3">
                            <MudText Typo="Typo.body1" Color="Color.Secondary">
                                @r.HoursOfOperation
                            </MudText>
                        </MudItem>

                        <MudItem xs="2">
                            <MudChip T="string" Size="Size.Small" Variant="Variant.Filled" Color="@StatusColor(r.Status)">
                                @r.Status
                            </MudChip>
                        </MudItem>
                    </MudGrid>
                </MudCardContent>
            </MudCard>
        }
    </MudContainer>
}

@code {
    // ---------- CONFIG ----------
    private const string WorkerBase = "https://blue-disk-457f.fionncmurphy.workers.dev/api/bt4u";
    private const int MaxTrips = 999;                    // all trips for the day
    private const int MaxParallel = 6;                   // per-route concurrency cap
    private static readonly TimeSpan RequestTimeout = TimeSpan.FromSeconds(8);
    private static readonly string ServiceDateIso = DateTime.Today.ToString("yyyy-MM-dd");

    // ---------- MODELS ----------
    private sealed record RouteRow(
        string Short, string Name, string RouteColor, string RouteTextColor,
        string HoursOfOperation, string Status
    );

    // ---------- STATE ----------
    private readonly List<RouteRow> _rows = new();
    private List<RouteRow> _filtered = new();
    private RouteRow? _selected;
    private bool _loading = true;

    // Cache for first scheduled stop per route
    private readonly Dictionary<string, string> _firstStopCodeCache = new(StringComparer.OrdinalIgnoreCase);

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadRoutesAndStatsAsync();
            _filtered = new(_rows);
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // ---------- LOAD ROUTES + HOURS + STATUS ----------
    private async Task LoadRoutesAndStatsAsync()
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var routesRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetCurrentRoutes", cts.Token);

            var routes = ParseRoutes(routesRoot);

            _rows.Clear();

            using var sem = new SemaphoreSlim(MaxParallel);
            var tasks = routes.Select(async r =>
            {
                await sem.WaitAsync();
                try
                {
                    var timesTask = GetRouteTimesIsoAsync(r.Short);
                    var statusTask = GetStatusAsync(r.Short);
                    await Task.WhenAll(timesTask, statusTask);

                    var times = timesTask.Result;
                    var hours = times.Count > 0
                        ? $"{times.Min():h:mm tt} - {times.Max():h:mm tt}"
                        : "—";

                    var status = statusTask.Result;

                    lock (_rows)
                    {
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, hours, status));
                    }
                }
                catch
                {
                    lock (_rows)
                    {
                        _rows.Add(new RouteRow(r.Short, r.Name, r.RouteColor, r.RouteTextColor, "—", "On Time"));
                    }
                }
                finally
                {
                    sem.Release();
                }
            }).ToArray();

            await Task.WhenAll(tasks);
            _rows.Sort((a, b) => string.Compare(a.Short, b.Short, StringComparison.OrdinalIgnoreCase));
        }
        catch
        {
            _rows.Clear();
        }
    }

    // ---------- HOURS OF OPERATION (ISO/XML exact fields) ----------
    private async Task<List<DateTime>> GetRouteTimesIsoAsync(string routeShortName)
    {
        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var url = $"{WorkerBase}?method=GetArrivalAndDepartureTimesForRoutes" +
                      $"&routeShortNames={Uri.EscapeDataString(routeShortName)}" +
                      $"&serviceDate={ServiceDateIso}" +
                      $"&noOfTrips={MaxTrips}";
            var root = await Http.GetFromJsonAsync<JsonElement>(url, cts.Token);
            return ExtractTimes(root);
        }
        catch { return new(); }
    }

    // Extract only CalculatedDepartureTime / CalculatedArrivalTime (ISO8601 with offset)
    private static List<DateTime> ExtractTimes(JsonElement root)
    {
        var results = new List<DateTime>();

        // JSON array (if worker ever returns rows as JSON)
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Value.ValueKind != JsonValueKind.String) continue;

                    var name = p.Name;
                    if (name.Equals("CalculatedDepartureTime", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("CalculatedArrivalTime", StringComparison.OrdinalIgnoreCase))
                    {
                        var s = p.Value.GetString();
                        if (TryParseTime(s, out var dt)) results.Add(dt);
                    }
                }
            }
            return CleanupTimes(results);
        }

        // XML string wrapped in { "xml": "<DocumentElement>..." }
        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString();
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);

                // Only pull the calculated times; ignore legacy StartTime
                var times =
                    x.Descendants("DeparturesForRoute")
                     .SelectMany(n => new[]
                     {
                         n.Element("CalculatedDepartureTime")?.Value?.Trim(),
                         n.Element("CalculatedArrivalTime")?.Value?.Trim()
                     })
                     .Where(s => !string.IsNullOrWhiteSpace(s));

                foreach (var s in times!)
                {
                    if (TryParseTime(s, out var dt)) results.Add(dt);
                }
            }
        }

        return CleanupTimes(results);
    }

    // ---------- STATUS (uses next departure at first scheduled stop) ----------
    private async Task<string> GetStatusAsync(string routeShortName)
    {
        try
        {
            var stopCode = await GetFirstStopCodeAsync(routeShortName);
            if (string.IsNullOrWhiteSpace(stopCode))
                return "On Time";

            using var cts = new CancellationTokenSource(RequestTimeout);
            var nextRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetNextDepartures&routeShortName={Uri.EscapeDataString(routeShortName)}&stopCode={Uri.EscapeDataString(stopCode)}",
                cts.Token);

            if (TryExtractNextTimes(nextRoot, out var scheduled, out var predicted))
            {
                var minutes = Math.Round((predicted - scheduled).TotalMinutes);
                if (minutes <= -2) return "Running Early";
                if (minutes >= 3) return "Running Late";
                return "On Time";
            }
        }
        catch { /* ignore */ }

        return "On Time";
    }

    private async Task<string> GetFirstStopCodeAsync(string routeShortName)
    {
        if (_firstStopCodeCache.TryGetValue(routeShortName, out var cached))
            return cached;

        try
        {
            using var cts = new CancellationTokenSource(RequestTimeout);
            var stopsRoot = await Http.GetFromJsonAsync<JsonElement>(
                $"{WorkerBase}?method=GetScheduledStopCodes&routeShortName={Uri.EscapeDataString(routeShortName)}",
                cts.Token);

            var code = ParseFirstStopCode(stopsRoot);
            if (!string.IsNullOrWhiteSpace(code))
                _firstStopCodeCache[routeShortName] = code;

            return code;
        }
        catch { return ""; }
    }

    // ---------- UI / HELPERS ----------
    private async Task OnRouteChanged(RouteRow? value)
    {
        _selected = value;
        _filtered = _selected is null ? new(_rows) : _rows.Where(r => r.Short == _selected.Short).ToList();
        await InvokeAsync(StateHasChanged);
    }

    private static Color StatusChipColor(string s) => s switch
    {
        "Running Early" => Color.Info,
        "Running Late" => Color.Error,
        "On Time" => Color.Success,
        _ => Color.Default
    };

    private static Color StatusColor(string s) => StatusChipColor(s);

    // ---------- Parsers ----------
    private static List<(string Short, string Name, string RouteColor, string RouteTextColor)> ParseRoutes(JsonElement root)
    {
        var list = new List<(string, string, string, string)>();

        if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var doc = XDocument.Parse(xml);
                foreach (var e in doc.Descendants("CurrentRoutes"))
                {
                    var name = e.Element("RouteName")?.Value?.Trim() ?? "";
                    var shortName = e.Element("RouteShortName")?.Value?.Trim() ?? "";
                    var color = e.Element("RouteColor")?.Value?.Trim() ?? "888888";
                    var text = e.Element("RouteTextColor")?.Value?.Trim() ?? "FFFFFF";

                    if (!string.IsNullOrWhiteSpace(shortName) && !string.IsNullOrWhiteSpace(name))
                        list.Add((shortName, name, color, text));
                }
            }
        }
        return list;
    }

    private static string ParseFirstStopCode(JsonElement root)
    {
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                foreach (var p in row.EnumerateObject())
                {
                    if (p.Name.Contains("StopCode", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                    if (p.Name.Equals("Code", StringComparison.OrdinalIgnoreCase) && p.Value.ValueKind == JsonValueKind.String)
                        return p.Value.GetString() ?? "";
                }
            }
        }
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                var code = x.Descendants().FirstOrDefault(e =>
                    e.Name.LocalName.Equals("StopCode", StringComparison.OrdinalIgnoreCase) ||
                    e.Name.LocalName.Equals("Code", StringComparison.OrdinalIgnoreCase));
                if (code is not null) return code.Value?.Trim() ?? "";
            }
        }
        return "";
    }

    private static bool TryExtractNextTimes(JsonElement root, out DateTime scheduled, out DateTime predicted)
    {
        scheduled = default;
        predicted = default;

        // JSON array
        if (root.ValueKind == JsonValueKind.Array)
        {
            foreach (var row in root.EnumerateArray())
            {
                var (sch, est) = ExtractTimesFromObj(row);
                if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
            }
        }
        // XML wrapper
        else if (root.ValueKind == JsonValueKind.Object && root.TryGetProperty("xml", out var xmlNode))
        {
            var xml = xmlNode.GetString() ?? "";
            if (!string.IsNullOrWhiteSpace(xml))
            {
                var x = XDocument.Parse(xml);
                foreach (var n in x.Descendants("DeparturesForRoute"))
                {
                    DateTime sch = default, est = default;

                    var schedStr = n.Element("ScheduledDepartureTime")?.Value?.Trim()
                                   ?? n.Element("ScheduledArrivalTime")?.Value?.Trim();
                    var predStr = n.Element("CalculatedDepartureTime")?.Value?.Trim()
                                   ?? n.Element("CalculatedArrivalTime")?.Value?.Trim();

                    if (!string.IsNullOrWhiteSpace(schedStr) && TryParseTime(schedStr, out var a)) sch = a;
                    if (!string.IsNullOrWhiteSpace(predStr) && TryParseTime(predStr, out var b)) est = b;

                    if (sch != default && est != default) { scheduled = sch; predicted = est; return true; }
                }
            }
        }
        return false;

        static (DateTime sch, DateTime est) ExtractTimesFromObj(JsonElement obj)
        {
            DateTime sch = default, est = default;
            foreach (var p in obj.EnumerateObject())
            {
                if (p.Value.ValueKind != JsonValueKind.String) continue;
                var name = p.Name;
                var s = p.Value.GetString();

                if ((name.Contains("Scheduled", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Schedule", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var a)) sch = a;

                if ((name.Contains("Calculated", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Pred", StringComparison.OrdinalIgnoreCase) ||
                     name.Contains("Est", StringComparison.OrdinalIgnoreCase)) &&
                    TryParseTime(s, out var b)) est = b;
            }
            return (sch, est);
        }
    }

    private static bool TryParseTime(string? s, out DateTime dt) => TryParseDate(s, out dt);

    // STRICT: API returns ISO 8601 with offset, e.g. 2025-10-20T21:47:02-04:00
    private static bool TryParseDate(string? s, out DateTime dt)
    {
        dt = default;
        if (string.IsNullOrWhiteSpace(s)) return false;

        if (DateTimeOffset.TryParseExact(
                s.Trim(),
                "yyyy-MM-dd'T'HH:mm:sszzz",
                System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None,
                out var dto))
        {
            dt = dto.LocalDateTime; // convert to local for display (DST-safe)
            return true;
        }

        return false;
    }

    private static List<DateTime> CleanupTimes(List<DateTime> times)
    {
        // Drop “midnight placeholders” if real times exist
        if (times.Any(t => t.TimeOfDay != TimeSpan.Zero))
            times = times.Where(t => t.TimeOfDay != TimeSpan.Zero).ToList();

        // Drop obvious legacy/sentinel years if they sneak in
        times = times.Where(t => t.Year >= 2000).ToList();

        return times.Distinct().OrderBy(t => t).ToList();
    }
}
